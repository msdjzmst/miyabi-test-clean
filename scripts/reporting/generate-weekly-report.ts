#!/usr/bin/env tsx
/**
 * Generate Weekly Report from GitHub Projects V2
 *
 * Creates a comprehensive weekly report with:
 * - Agent execution statistics
 * - KPI metrics
 * - Top quality issues
 * - Cost tracking
 * - Markdown-formatted Issue
 *
 * Issue #5 Phase A: Data Persistence Layer
 */

import GitHubProjectAPI, { type WeeklyReport, type AgentMetrics } from '../github/github-project-api';
import { Octokit } from '@octokit/rest';

// ============================================================================
// Report Formatting
// ============================================================================

function formatDuration(ms: number): string {
  if (ms < 1000) {return `${ms}ms`;}
  if (ms < 60000) {return `${(ms / 1000).toFixed(1)}s`;}
  if (ms < 3600000) {return `${(ms / 60000).toFixed(1)}m`;}
  return `${(ms / 3600000).toFixed(1)}h`;
}

function formatCost(usd: number): string {
  return `$${usd.toFixed(4)}`;
}

function formatMarkdownReport(report: WeeklyReport): string {
  const { week, totalIssues, completedIssues, agentMetrics, topQualityIssues, totalCost } = report;

  return `
## üìä Weekly Agent Report

**Period**: ${week}

---

### üìà Overview

| Metric | Value |
|--------|-------|
| **Total Issues** | ${totalIssues} |
| **Completed Issues** | ${completedIssues} (${((completedIssues / totalIssues) * 100).toFixed(1)}%) |
| **Total Cost** | ${formatCost(totalCost)} |
| **Active Agents** | ${agentMetrics.length} |

---

### ü§ñ Agent Performance

${formatAgentTable(agentMetrics)}

---

### üèÜ Top Quality Issues

${formatTopQualityTable(topQualityIssues)}

---

### üí∞ Cost Breakdown

${formatCostChart(agentMetrics)}

---

### üìä KPI Summary

| KPI | Target | Actual | Status |
|-----|--------|--------|--------|
| **Quality Score** | ‚â• 80 | ${calculateAvgQuality(agentMetrics).toFixed(1)} | ${calculateAvgQuality(agentMetrics) >= 80 ? '‚úÖ' : '‚ö†Ô∏è'} |
| **Avg Duration** | ‚â§ 5min | ${formatDuration(calculateAvgDuration(agentMetrics))} | ${calculateAvgDuration(agentMetrics) <= 300000 ? '‚úÖ' : '‚ö†Ô∏è'} |
| **Weekly Cost** | ‚â§ $10 | ${formatCost(totalCost)} | ${totalCost <= 10 ? '‚úÖ' : '‚ö†Ô∏è'} |
| **Completion Rate** | ‚â• 70% | ${((completedIssues / totalIssues) * 100).toFixed(1)}% | ${(completedIssues / totalIssues) >= 0.7 ? '‚úÖ' : '‚ö†Ô∏è'} |

---

### üîç Insights

${generateInsights(report)}

---

### üìù Recommendations

${generateRecommendations(report)}

---

**Generated by**: Agentic OS Weekly Reporter
**Timestamp**: ${new Date().toISOString()}
**Automated by**: [generate-weekly-report.ts](../scripts/generate-weekly-report.ts)

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
`;
}

function formatAgentTable(metrics: AgentMetrics[]): string {
  const sorted = [...metrics].sort((a, b) => b.executionCount - a.executionCount);

  let table = `
| Agent | Executions | Avg Duration | Avg Cost | Avg Quality | Total Cost |
|-------|------------|--------------|----------|-------------|------------|
`;

  for (const metric of sorted) {
    table += `| **${metric.agent}** | ${metric.executionCount} | ${formatDuration(metric.avgDuration)} | ${formatCost(metric.avgCost)} | ${metric.avgQualityScore.toFixed(1)}/100 | ${formatCost(metric.totalCost)} |\n`;
  }

  return table;
}

function formatTopQualityTable(
  issues: Array<{ number: number; title: string; score: number }>,
): string {
  if (issues.length === 0) {
    return '_No quality scores recorded this week_';
  }

  let table = `
| Rank | Issue | Quality Score |
|------|-------|---------------|
`;

  issues.forEach((issue, index) => {
    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '  ';
    table += `| ${medal} ${index + 1} | [#${issue.number}](../../issues/${issue.number}) ${issue.title} | **${issue.score}/100** |\n`;
  });

  return table;
}

function formatCostChart(metrics: AgentMetrics[]): string {
  const sorted = [...metrics].sort((a, b) => b.totalCost - a.totalCost);
  const maxCost = sorted[0]?.totalCost || 1;

  let chart = '\n```\n';
  for (const metric of sorted) {
    const barLength = Math.round((metric.totalCost / maxCost) * 40);
    const bar = '‚ñà'.repeat(barLength);
    chart += `${metric.agent.padEnd(20)} ${bar} ${formatCost(metric.totalCost)}\n`;
  }
  chart += '```\n';

  return chart;
}

function calculateAvgQuality(metrics: AgentMetrics[]): number {
  if (metrics.length === 0) {return 0;}
  const sum = metrics.reduce((acc, m) => acc + m.avgQualityScore, 0);
  return sum / metrics.length;
}

function calculateAvgDuration(metrics: AgentMetrics[]): number {
  if (metrics.length === 0) {return 0;}
  const sum = metrics.reduce((acc, m) => acc + m.avgDuration, 0);
  return sum / metrics.length;
}

function generateInsights(report: WeeklyReport): string {
  const insights: string[] = [];

  // Completion rate insight
  const completionRate = (report.completedIssues / report.totalIssues) * 100;
  if (completionRate >= 80) {
    insights.push('‚úÖ **Excellent completion rate** - Team is delivering consistently');
  } else if (completionRate >= 60) {
    insights.push('‚ö†Ô∏è **Good completion rate** - Some issues may need attention');
  } else {
    insights.push('üî¥ **Low completion rate** - Consider reviewing task complexity');
  }

  // Quality insight
  const avgQuality = calculateAvgQuality(report.agentMetrics);
  if (avgQuality >= 90) {
    insights.push('üèÜ **Outstanding quality** - Code quality exceeds expectations');
  } else if (avgQuality >= 80) {
    insights.push('‚úÖ **High quality** - Meeting quality standards');
  } else {
    insights.push('‚ö†Ô∏è **Quality needs attention** - Consider additional reviews');
  }

  // Cost insight
  if (report.totalCost <= 5) {
    insights.push('üí∞ **Cost efficient** - Operating well within budget');
  } else if (report.totalCost <= 10) {
    insights.push('‚úÖ **On budget** - Cost tracking nominal');
  } else {
    insights.push('‚ö†Ô∏è **High cost week** - Review API usage patterns');
  }

  // Agent insight
  const mostActive = report.agentMetrics.sort(
    (a, b) => b.executionCount - a.executionCount,
  )[0];
  if (mostActive) {
    insights.push(
      `ü§ñ **Most active**: ${mostActive.agent} (${mostActive.executionCount} executions)`,
    );
  }

  return insights.map((i) => `- ${i}`).join('\n');
}

function generateRecommendations(report: WeeklyReport): string {
  const recommendations: string[] = [];

  // Quality recommendations
  const avgQuality = calculateAvgQuality(report.agentMetrics);
  if (avgQuality < 80) {
    recommendations.push(
      '1. **Quality Improvement**: Consider adding more test coverage and stricter linting rules',
    );
  }

  // Duration recommendations
  const avgDuration = calculateAvgDuration(report.agentMetrics);
  if (avgDuration > 300000) {
    // > 5 minutes
    recommendations.push(
      '2. **Performance**: Review agent execution times - consider optimizing long-running tasks',
    );
  }

  // Cost recommendations
  if (report.totalCost > 10) {
    recommendations.push(
      '3. **Cost Optimization**: High API usage detected - review caching strategies and API call patterns',
    );
  }

  // Completion recommendations
  const completionRate = (report.completedIssues / report.totalIssues) * 100;
  if (completionRate < 70) {
    recommendations.push(
      '4. **Delivery**: Low completion rate - consider breaking down complex issues into smaller tasks',
    );
  }

  if (recommendations.length === 0) {
    recommendations.push('‚úÖ **No major recommendations** - System is operating optimally');
  }

  return recommendations.join('\n');
}

// ============================================================================
// GitHub Issue Creation
// ============================================================================

async function createWeeklyReportIssue(
  token: string,
  owner: string,
  repo: string,
  report: WeeklyReport,
): Promise<number> {
  const octokit = new Octokit({ auth: token });

  const title = `üìä Weekly Report: ${report.week}`;
  const body = formatMarkdownReport(report);

  try {
    const { data: issue } = await octokit.rest.issues.create({
      owner,
      repo,
      title,
      body,
      labels: ['report', 'weekly', 'automated'],
    });

    console.log(`‚úÖ Created weekly report issue: #${issue.number}`);
    console.log(`   URL: ${issue.html_url}`);

    return issue.number;
  } catch (error) {
    console.error('‚ùå Failed to create issue:', error);
    throw error;
  }
}

// ============================================================================
// CLI Interface
// ============================================================================

async function main() {
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    console.error('‚ùå GITHUB_TOKEN environment variable is required');
    process.exit(1);
  }

  const owner = process.env.GITHUB_OWNER || 'ShunsukeHayashi';
  const repo = process.env.GITHUB_REPO || 'Autonomous-Operations';
  const projectNumber = parseInt(process.env.PROJECT_NUMBER || '1', 10);

  console.log('üìä Generating weekly report...');

  const api = new GitHubProjectAPI(token, { owner, repo, projectNumber });

  try {
    const report = await api.generateWeeklyReport();

    console.log(`\n${  formatMarkdownReport(report)}`);

    // Check if should create Issue
    const createIssue = process.argv.includes('--create-issue');

    if (createIssue) {
      console.log('\nüìù Creating GitHub Issue...');
      await createWeeklyReportIssue(token, owner, repo, report);
    } else {
      console.log('\nüí° Tip: Run with --create-issue to create a GitHub Issue');
    }

    console.log('\n‚úÖ Weekly report generated successfully');
  } catch (error) {
    console.error('‚ùå Error generating report:', error);
    process.exit(1);
  }
}

// ESM module check
import { fileURLToPath } from 'node:url';

if (process.argv[1] === fileURLToPath(import.meta.url)) {
  main();
}
