/**
 * IssueAgent - Issueåˆ†æAgent
 *
 * è­˜å­¦ç†è«–é©ç”¨:
 * - è²¬ä»»: GitHubã®Issueã‚’è§£æã—ã€é©åˆ‡ãªãƒ©ãƒ™ãƒ«ã¨è¤‡é›‘åº¦ã‚’åˆ¤å®š
 * - æ¨©é™: ãƒ©ãƒ™ãƒ«è‡ªå‹•ä»˜ä¸ã€è¤‡é›‘åº¦æ¨å®šã€å„ªå…ˆåº¦åˆ¤å®š
 * - éšå±¤: Specialist Layer
 *
 * Phase 8-1: Real API Integration
 */
import { AnthropicClient } from "../clients/AnthropicClient.js";
import { ClaudeCodeClient } from "../clients/ClaudeCodeClient.js";
import { GitHubClient } from "../clients/GitHubClient.js";
/**
 * IssueAgentå®Ÿè£…
 *
 * GitHub Issueå–å¾— â†’ Claudeåˆ†æ â†’ ãƒ©ãƒ™ãƒ«ä»˜ä¸ â†’ è¤‡é›‘åº¦åˆ¤å®š
 */
export class IssueAgent {
    anthropicClient;
    claudeCodeClient;
    githubClient;
    constructor(config) {
        if (config) {
            if (config.useClaudeCode) {
                this.claudeCodeClient = new ClaudeCodeClient();
            }
            else if (config.anthropicApiKey) {
                this.anthropicClient = new AnthropicClient(config.anthropicApiKey);
            }
            if (config.githubToken) {
                this.githubClient = new GitHubClient(config.githubToken);
            }
        }
    }
    /**
     * ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
     */
    async analyze(input) {
        try {
            // Select client to use (real API or mock)
            const githubClient = input.githubClient || this.githubClient;
            const anthropicClient = input.anthropicClient || this.anthropicClient;
            const claudeCodeClient = input.claudeCodeClient || this.claudeCodeClient;
            const useRealAPI = input.useRealAPI !== false && !!(githubClient || anthropicClient || claudeCodeClient);
            // 1. Issueå–å¾—ï¼ˆGitHub API - Phase 8ã§å®ŸAPIçµ±åˆï¼‰
            const issue = await this.fetchIssue(input, githubClient);
            // 2. Claudeåˆ†æï¼ˆAnthropic API or Claude Code - Phase 9çµ±åˆï¼‰
            const analysis = await this.analyzeWithClaude({ ...issue, number: issue.number }, anthropicClient, claudeCodeClient, useRealAPI);
            // 3. ãƒ©ãƒ™ãƒ«ä»˜ä¸ï¼ˆGitHub API - Phase 8ã§å®ŸAPIçµ±åˆï¼‰
            if (useRealAPI) {
                await this.applyLabels(input, analysis.labels, githubClient);
            }
            return {
                success: true,
                data: {
                    number: issue.number,
                    title: issue.title,
                    body: issue.body,
                    labels: analysis.labels,
                    complexity: analysis.complexity,
                    priority: analysis.priority,
                    type: analysis.type,
                    tokensUsed: analysis.tokensUsed,
                    cost: analysis.cost,
                },
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : "Unknown error occurred",
            };
        }
    }
    /**
     * GitHub Issueã‚’APIçµŒç”±ã§å–å¾—
     *
     * Phase 8: Real GitHub API integration
     */
    async fetchIssue(input, githubClient) {
        if (githubClient) {
            // Real API implementation
            const issue = await githubClient.getIssue(input.owner, input.repository, input.issueNumber);
            return {
                number: issue.number,
                title: issue.title,
                body: issue.body,
            };
        }
        else {
            // Mock implementation (fallback)
            return {
                number: input.issueNumber,
                title: `Mock Issue #${input.issueNumber}`,
                body: "Mock issue body for testing",
            };
        }
    }
    /**
     * Claude Sonnet 4ã§è‡ªç„¶è¨€èªè§£æ
     *
     * Phase 8: Real Claude API integration
     * Phase 9: Claude Code CLI integration
     */
    async analyzeWithClaude(issue, anthropicClient, claudeCodeClient, useRealAPI) {
        if (useRealAPI && claudeCodeClient) {
            // Phase 9: Claude Code implementation
            const result = await claudeCodeClient.analyzeIssue({
                title: issue.title,
                body: issue.body || "",
                number: issue.number || 0,
            });
            return {
                labels: result.labels,
                complexity: result.complexity,
                priority: result.priority,
                type: result.type,
                tokensUsed: { input: 0, output: 0 }, // Claude Code doesn't track tokens
                cost: 0, // Free!
            };
        }
        else if (useRealAPI && anthropicClient) {
            // Phase 8: Real Anthropic API implementation
            const result = await anthropicClient.analyzeIssue(issue.title, issue.body);
            // Calculate cost
            const cost = anthropicClient.calculateCost(result.tokensUsed);
            return {
                labels: result.labels,
                complexity: result.complexity,
                priority: result.priority,
                type: result.type,
                tokensUsed: result.tokensUsed,
                cost,
            };
        }
        else {
            // Mock implementation (fallback)
            const analysis = this.keywordBasedAnalysis(issue);
            return {
                ...analysis,
                tokensUsed: undefined,
                cost: undefined,
            };
        }
    }
    /**
     * Claudeåˆ†æç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ
     */
    buildAnalysisPrompt(issue) {
        return `
ä»¥ä¸‹ã®GitHub Issueã‚’è§£æã—ã€é©åˆ‡ãªãƒ©ãƒ™ãƒ«ã€è¤‡é›‘åº¦ã€å„ªå…ˆåº¦ã€ç¨®é¡ã‚’åˆ¤å®šã—ã¦ãã ã•ã„ã€‚

## Issueæƒ…å ±
**Title**: ${issue.title}
**Body**: ${issue.body || "(ç©ºç™½)"}

## ãƒ©ãƒ™ãƒ«ä½“ç³»ï¼ˆ116ãƒ©ãƒ™ãƒ«ã€15ã‚«ãƒ†ã‚´ãƒªï¼‰
- ğŸ·ï¸ type: bug, feature, refactor, docs, test, chore
- ğŸ¯ priority: P0-Critical, P1-High, P2-Medium, P3-Low
- ğŸ“Š complexity: small (<4h), medium (4-8h), large (1-3d), xlarge (>3d)
- ğŸ—ï¸ state: backlog, implementing, review, done
- ğŸ¤– agent: coordinator, issue, codegen, review, pr, test, deploy
- ğŸ”§ tech: rust, typescript, python, go
- ğŸŒ area: cli, tui, mcp, sdk, core
- ğŸ“¦ scope: api, ui, db, infra, security
- ğŸ¨ ux: a11y, i18n, perf, responsive
- ğŸ”¬ testing: unit, integration, e2e
- ğŸ“š docs: readme, guide, api-docs
- ğŸš€ release: major, minor, patch, alpha, beta
- ğŸ”’ security: vuln, cve, audit
- ğŸ’° cost: low, medium, high
- ğŸ“ˆ impact: breaking, enhancement, fix

## å‡ºåŠ›å½¢å¼ï¼ˆJSONï¼‰
{
  "labels": ["ğŸ·ï¸ type:bug", "ğŸ¯ priority:P1-High", ...],
  "complexity": "medium",
  "priority": "P1",
  "type": "bug"
}

**é‡è¦**: 116ãƒ©ãƒ™ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã«å³å¯†ã«å¾“ã£ã¦ãã ã•ã„ã€‚
    `.trim();
    }
    /**
     * ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®ç°¡æ˜“åˆ†æ
     *
     * Claudeçµ±åˆå‰ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…
     */
    keywordBasedAnalysis(issue) {
        const text = `${issue.title} ${issue.body || ""}`.toLowerCase();
        // Typeåˆ¤å®š
        let type = "feature";
        if (text.includes("bug") || text.includes("error") || text.includes("fix"))
            type = "bug";
        else if (text.includes("refactor") || text.includes("cleanup"))
            type = "refactor";
        else if (text.includes("docs") || text.includes("documentation"))
            type = "docs";
        else if (text.includes("test"))
            type = "test";
        else if (text.includes("chore") ||
            text.includes("deps") ||
            text.includes("dependency"))
            type = "chore";
        // Priorityåˆ¤å®š
        let priority = "P2";
        if (text.includes("critical") ||
            text.includes("urgent") ||
            text.includes("security"))
            priority = "P0";
        else if (text.includes("high") || text.includes("important"))
            priority = "P1";
        else if (text.includes("low") || text.includes("nice-to-have"))
            priority = "P3";
        // Complexityåˆ¤å®š
        let complexity = "medium";
        if (text.includes("simple") ||
            text.includes("quick") ||
            text.includes("typo"))
            complexity = "small";
        else if (text.includes("large") ||
            text.includes("major") ||
            text.includes("refactor"))
            complexity = "large";
        else if (text.includes("rewrite") ||
            text.includes("migration") ||
            text.includes("breaking"))
            complexity = "xlarge";
        // ãƒ©ãƒ™ãƒ«ç”Ÿæˆ
        const labels = [
            `ğŸ·ï¸ type:${type}`,
            `ğŸ¯ priority:${priority}-${this.getPriorityLabel(priority)}`,
            `ğŸ“Š complexity:${complexity}`,
        ];
        // æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯æ¨å®š
        if (text.includes("rust"))
            labels.push("ğŸ”§ tech:rust");
        if (text.includes("typescript") || text.includes("ts"))
            labels.push("ğŸ”§ tech:typescript");
        if (text.includes("python") || text.includes("py"))
            labels.push("ğŸ”§ tech:python");
        // ã‚¨ãƒªã‚¢æ¨å®š
        if (text.includes("cli"))
            labels.push("ğŸŒ area:cli");
        if (text.includes("tui"))
            labels.push("ğŸŒ area:tui");
        if (text.includes("mcp"))
            labels.push("ğŸŒ area:mcp");
        if (text.includes("sdk"))
            labels.push("ğŸŒ area:sdk");
        return { labels, complexity, priority, type };
    }
    /**
     * Priority labelå–å¾—
     */
    getPriorityLabel(priority) {
        switch (priority) {
            case "P0":
                return "Critical";
            case "P1":
                return "High";
            case "P2":
                return "Medium";
            case "P3":
                return "Low";
        }
    }
    /**
     * ãƒ©ãƒ™ãƒ«ä»˜ä¸ï¼ˆGitHub APIï¼‰
     *
     * Phase 8: Real GitHub API integration
     */
    async applyLabels(input, labels, githubClient) {
        if (githubClient) {
            // Real API implementation
            await githubClient.addLabels(input.owner, input.repository, input.issueNumber, labels);
            console.log(`[IssueAgent] Applied labels to #${input.issueNumber}:`, labels);
        }
        else {
            // Mock implementation (fallback)
            console.log(`[IssueAgent] Would apply labels to #${input.issueNumber}:`, labels);
        }
    }
    /**
     * å·¥æ•°æ¨å®šï¼ˆcomplexityã‹ã‚‰æ¨å®šæ™‚é–“ã«å¤‰æ›ï¼‰
     */
    estimateEffort(complexity) {
        switch (complexity) {
            case "small":
                return "1h";
            case "medium":
                return "4h";
            case "large":
                return "1d";
            case "xlarge":
                return "1w";
        }
    }
}
//# sourceMappingURL=IssueAgent.js.map