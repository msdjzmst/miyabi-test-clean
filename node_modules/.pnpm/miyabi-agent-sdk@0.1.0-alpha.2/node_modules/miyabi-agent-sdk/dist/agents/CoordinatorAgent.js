/**
 * CoordinatorAgent - 最上位意思決定Agent
 *
 * 識学理論適用:
 * - 責任: タスク全体の統括と並列実行制御
 * - 権限: 他Agentへのタスク委譲、並列実行数決定、Critical Path判定
 * - 階層: Coordinator Layer（最上位）
 */
/**
 * CoordinatorAgent実装
 *
 * タスク分解 → DAG生成 → Critical Path特定 → 並列実行制御
 */
export class CoordinatorAgent {
    maxConcurrency = 3; // 最大並列実行数
    /**
     * メイン実行ロジック
     */
    async execute(input) {
        try {
            // 1. Issue分析（IssueAgentに委譲する想定 - Phase 6で統合）
            const issueData = await this.analyzeIssue(input);
            // 2. DAG生成
            const taskGraph = this.generateDAG(issueData);
            // 3. DAG検証（循環依存チェック）
            this.validateDAG(taskGraph);
            // 4. Critical Path特定
            const criticalPath = this.findCriticalPath(taskGraph);
            // 5. 並列実行グループ化
            const parallelGroups = this.groupParallelizable(taskGraph);
            // 6. 推定時間計算
            const estimatedDuration = this.calculateDuration(taskGraph, criticalPath);
            return {
                success: true,
                data: {
                    taskGraph,
                    criticalPath,
                    parallelGroups,
                    estimatedDuration,
                },
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : "Unknown error occurred",
            };
        }
    }
    /**
     * Issue分析（現時点ではモック - IssueAgent実装後に置き換え）
     */
    async analyzeIssue(input) {
        // TODO: IssueAgent統合
        return {
            number: input.issueNumber,
            title: "Mock Issue",
            body: null,
            labels: [],
            complexity: "medium",
            priority: "P1",
            type: "feature",
        };
    }
    /**
     * DAG生成ロジック
     *
     * IssueDataから依存関係グラフを生成
     */
    generateDAG(issueData) {
        const nodes = [];
        const edges = [];
        // 複雑度に応じてタスク分解
        switch (issueData.complexity) {
            case "small":
                // Small: 単純なタスク（調査 → 実装 → PR）
                nodes.push({
                    id: "task-1",
                    description: "Issue調査・要件整理",
                    agent: "IssueAgent",
                    estimatedTime: 15,
                    dependencies: [],
                }, {
                    id: "task-2",
                    description: "コード実装",
                    agent: "CodeGenAgent",
                    estimatedTime: 30,
                    dependencies: ["task-1"],
                }, {
                    id: "task-3",
                    description: "コードレビュー",
                    agent: "ReviewAgent",
                    estimatedTime: 15,
                    dependencies: ["task-2"],
                }, {
                    id: "task-4",
                    description: "PR作成",
                    agent: "PRAgent",
                    estimatedTime: 10,
                    dependencies: ["task-3"],
                });
                edges.push({ from: "task-1", to: "task-2" }, { from: "task-2", to: "task-3" }, { from: "task-3", to: "task-4" });
                break;
            case "medium":
                // Medium: 複数ファイル変更（調査 → [実装1, 実装2] → Review → PR）
                nodes.push({
                    id: "task-1",
                    description: "Issue調査・要件整理",
                    agent: "IssueAgent",
                    estimatedTime: 30,
                    dependencies: [],
                }, {
                    id: "task-2",
                    description: "コア機能実装",
                    agent: "CodeGenAgent",
                    estimatedTime: 60,
                    dependencies: ["task-1"],
                }, {
                    id: "task-3",
                    description: "テストコード実装",
                    agent: "CodeGenAgent",
                    estimatedTime: 45,
                    dependencies: ["task-1"],
                }, {
                    id: "task-4",
                    description: "コードレビュー",
                    agent: "ReviewAgent",
                    estimatedTime: 30,
                    dependencies: ["task-2", "task-3"],
                }, {
                    id: "task-5",
                    description: "PR作成",
                    agent: "PRAgent",
                    estimatedTime: 10,
                    dependencies: ["task-4"],
                });
                edges.push({ from: "task-1", to: "task-2" }, { from: "task-1", to: "task-3" }, { from: "task-2", to: "task-4" }, { from: "task-3", to: "task-4" }, { from: "task-4", to: "task-5" });
                break;
            case "large":
            case "xlarge":
                // Large/XLarge: 大規模変更（設計 → [実装1, 実装2, 実装3] → Review → Test → PR）
                nodes.push({
                    id: "task-1",
                    description: "Issue調査・設計",
                    agent: "IssueAgent",
                    estimatedTime: 60,
                    dependencies: [],
                }, {
                    id: "task-2",
                    description: "モジュールA実装",
                    agent: "CodeGenAgent",
                    estimatedTime: 120,
                    dependencies: ["task-1"],
                }, {
                    id: "task-3",
                    description: "モジュールB実装",
                    agent: "CodeGenAgent",
                    estimatedTime: 120,
                    dependencies: ["task-1"],
                }, {
                    id: "task-4",
                    description: "モジュールC実装",
                    agent: "CodeGenAgent",
                    estimatedTime: 120,
                    dependencies: ["task-1"],
                }, {
                    id: "task-5",
                    description: "統合テスト",
                    agent: "TestAgent",
                    estimatedTime: 45,
                    dependencies: ["task-2", "task-3", "task-4"],
                }, {
                    id: "task-6",
                    description: "コードレビュー",
                    agent: "ReviewAgent",
                    estimatedTime: 60,
                    dependencies: ["task-5"],
                }, {
                    id: "task-7",
                    description: "PR作成",
                    agent: "PRAgent",
                    estimatedTime: 15,
                    dependencies: ["task-6"],
                });
                edges.push({ from: "task-1", to: "task-2" }, { from: "task-1", to: "task-3" }, { from: "task-1", to: "task-4" }, { from: "task-2", to: "task-5" }, { from: "task-3", to: "task-5" }, { from: "task-4", to: "task-5" }, { from: "task-5", to: "task-6" }, { from: "task-6", to: "task-7" });
                break;
        }
        return { nodes, edges };
    }
    /**
     * DAG検証（循環依存チェック）
     */
    validateDAG(dag) {
        const visited = new Set();
        const recursionStack = new Set();
        const hasCycle = (nodeId) => {
            visited.add(nodeId);
            recursionStack.add(nodeId);
            const outgoingEdges = dag.edges.filter((e) => e.from === nodeId);
            for (const edge of outgoingEdges) {
                if (!visited.has(edge.to)) {
                    if (hasCycle(edge.to))
                        return true;
                }
                else if (recursionStack.has(edge.to)) {
                    return true; // 循環依存検出
                }
            }
            recursionStack.delete(nodeId);
            return false;
        };
        // 全ノードでチェック
        for (const node of dag.nodes) {
            if (!visited.has(node.id)) {
                if (hasCycle(node.id)) {
                    throw new Error(`Circular dependency detected in DAG at node: ${node.id}`);
                }
            }
        }
    }
    /**
     * Critical Path特定
     *
     * トポロジカルソート + 動的計画法で最長経路を探索
     */
    findCriticalPath(dag) {
        // トポロジカルソート
        const sorted = this.topologicalSort(dag);
        // 各ノードへの最大距離を計算
        const maxDistance = new Map();
        const predecessor = new Map();
        for (const nodeId of sorted) {
            const node = dag.nodes.find((n) => n.id === nodeId);
            if (!node)
                continue;
            const incomingEdges = dag.edges.filter((e) => e.to === nodeId);
            if (incomingEdges.length === 0) {
                // 開始ノード
                maxDistance.set(nodeId, node.estimatedTime);
                predecessor.set(nodeId, null);
            }
            else {
                // 最大距離を持つ親ノードを選択
                let maxDist = 0;
                let maxPred = null;
                for (const edge of incomingEdges) {
                    const parentDist = maxDistance.get(edge.from) || 0;
                    if (parentDist > maxDist) {
                        maxDist = parentDist;
                        maxPred = edge.from;
                    }
                }
                maxDistance.set(nodeId, maxDist + node.estimatedTime);
                predecessor.set(nodeId, maxPred);
            }
        }
        // 最大距離を持つノードを終点として、Critical Pathをバックトラック
        let maxDist = 0;
        let endNode = null;
        for (const [nodeId, dist] of maxDistance.entries()) {
            if (dist > maxDist) {
                maxDist = dist;
                endNode = nodeId;
            }
        }
        if (!endNode)
            return [];
        // バックトラック
        const criticalPath = [];
        let current = endNode;
        while (current) {
            criticalPath.unshift(current);
            current = predecessor.get(current) || null;
        }
        return criticalPath;
    }
    /**
     * トポロジカルソート（Kahn's Algorithm）
     */
    topologicalSort(dag) {
        const inDegree = new Map();
        const adjList = new Map();
        // 初期化
        for (const node of dag.nodes) {
            inDegree.set(node.id, 0);
            adjList.set(node.id, []);
        }
        // 入次数と隣接リスト構築
        for (const edge of dag.edges) {
            inDegree.set(edge.to, (inDegree.get(edge.to) || 0) + 1);
            adjList.get(edge.from)?.push(edge.to);
        }
        // 入次数0のノードをキューに追加
        const queue = [];
        for (const [nodeId, degree] of inDegree.entries()) {
            if (degree === 0)
                queue.push(nodeId);
        }
        const sorted = [];
        while (queue.length > 0) {
            const current = queue.shift();
            sorted.push(current);
            for (const neighbor of adjList.get(current) || []) {
                inDegree.set(neighbor, (inDegree.get(neighbor) || 0) - 1);
                if (inDegree.get(neighbor) === 0) {
                    queue.push(neighbor);
                }
            }
        }
        if (sorted.length !== dag.nodes.length) {
            throw new Error("DAG contains a cycle (topological sort failed)");
        }
        return sorted;
    }
    /**
     * 並列実行可能なタスクをグループ化
     */
    groupParallelizable(dag) {
        const groups = [];
        const completed = new Set();
        const sorted = this.topologicalSort(dag);
        while (completed.size < dag.nodes.length) {
            const currentGroup = [];
            for (const nodeId of sorted) {
                if (completed.has(nodeId))
                    continue;
                // 依存関係が全て完了しているかチェック
                const node = dag.nodes.find((n) => n.id === nodeId);
                if (!node)
                    continue;
                const allDepsCompleted = node.dependencies.every((dep) => completed.has(dep));
                if (allDepsCompleted) {
                    currentGroup.push(nodeId);
                    // 最大並列数を守る
                    if (currentGroup.length >= this.maxConcurrency)
                        break;
                }
            }
            // グループに追加
            if (currentGroup.length > 0) {
                groups.push(currentGroup);
                currentGroup.forEach((nodeId) => completed.add(nodeId));
            }
            else {
                // デッドロック防止
                break;
            }
        }
        return groups;
    }
    /**
     * 推定時間計算（Critical Pathの合計時間）
     */
    calculateDuration(dag, criticalPath) {
        let totalTime = 0;
        for (const nodeId of criticalPath) {
            const node = dag.nodes.find((n) => n.id === nodeId);
            if (node) {
                totalTime += node.estimatedTime;
            }
        }
        return totalTime;
    }
}
//# sourceMappingURL=CoordinatorAgent.js.map